{"componentChunkName":"component---node-modules-pauliescanlon-gatsby-theme-terminal-src-layouts-source-layout-js","path":"/posts/golang-notes/","result":{"data":{"mdx":{"id":"170e7e81-9db3-57c5-b892-711eb472441b","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Golang Notes\",\n  \"tags\": [\"notes\", \"golang\"],\n  \"date\": \"2020-06-05T00:00:00.000Z\",\n  \"author\": \"Akshay Ashok\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"These are the notes I made while doing the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.coursera.org/specializations/google-golang\"\n  }), mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"Coursera Golang Specialization\")), \"\\nfor quick reference.\"), mdx(\"h2\", null, \"Objects in Go\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Go does not use the term class.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A struct is a collection of data.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Go uses structs with associated methods.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Go uses a simplified object orientation: - no inheritance - no constructors - no generics\")), mdx(\"h2\", null, \"Concurrency\"), mdx(\"p\", null, \"..is the management of multiple tasks that (could theoretically) run at the same time. Concurrent programming enables parallelism:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"management of task execution\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"communication between tasks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"synchronization between tasks\\nGorutines represent concurrent tasks\\nChannels are used to communicate between tasks\\nSelect enables task synchronization\")), mdx(\"h2\", null, \"Pointer\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \".. is an address to data in memory\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"& operator returns the address of some data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"operator returns the data at some address\")))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"var x int = 1           //declaration and initialisation of an int\\nvar y int           //declaration of an int\\nvar ip *int         //declaration of a pointer to an int\\n\\nip = &x                 //setting ip to the address of x > ip now points to x\\ny = *ip             //setting y to the data stored at the address ip > y now is x > y = 1\\n----------------------------------------------------\\nvar ptr *int = new(int) //new() creates a var and returns pointer to that var, therfore *int\\n*ptr = 3\\nfmt.Println(*ptr)       //3\\nfmt.Println(ptr)        //some address\\n\")), mdx(\"h2\", null, \"Variable Scope\"), mdx(\"p\", null, \"A variable is accessible from block Bj if:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the variable is declared in Bi and\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Bi >= Bj\")), mdx(\"h2\", null, \"Memory: Stack vs Heap\"), mdx(\"p\", null, \"Stack: variables defined within a function - Memory will be deallocated when function call completed (in C for example)\\nHeap: Global variables - Needs to be explicitly deallocated ( in C for example), is fast but error-prone\"), mdx(\"h2\", null, \"Type conversion\"), mdx(\"p\", null, \"Use T() to convert, where T stands for the type you want to convert into\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"var x int32 = 1\\nvar x int16 = 2\\nx = y //error\\nx = int32(y)\\n\")), mdx(\"h2\", null, \"ASCII\"), mdx(\"p\", null, \"Each char is associated with an 8-bit number.\\n8 bits \\u2014> 0-255, not enough for different alphabets and symbols\"), mdx(\"h2\", null, \"Unicode\"), mdx(\"p\", null, \"Each char is associated with an 32-bit number.\\nUnicode is variable in length. From 8-bits to 32-bits.\\n8-bit UTF codes are the same as ASCII\"), mdx(\"h2\", null, \"Strings\"), mdx(\"p\", null, \"\\u2014 a sequence of bytes, each byte is a \\u201Crune\\u201D (Go specific, = UTF-8 code point)\\nGood packages: Unicode (for individual runes), String (for strings)\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"var hello = \\\"hello\\\"\\nvar test = hello[0]\\nfmt.Println(test) //104\\nfmt.Println(string(test)) //h\\n\")), mdx(\"h2\", null, \"Switch/case statement\"), mdx(\"p\", null, \"If x is 1, enter case 1, if x is 2, enter case 2\\u2026\\u2026..\\nCompared to C, no break statements are needed. Go will not fall through, it automatically breaks.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"switch x {\\ncase 1:\\n    fmt.printf(\\\"case 1\\\")\\ncase 1:\\n    fmt.printf(\\\"case 2\\\")\\ndefault:\\n    fmt.printf(\\\"default case\\\")\\n\")), mdx(\"h2\", null, \"Exported names\"), mdx(\"p\", null, \"When importing a package, you can refer only to its exported names. Any \\\"unexported\\\" names are not accessible from outside the package. A name is exported if it begins with a capital letter.\"), mdx(\"h2\", null, \"Variables\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"var i, j int = 1, 2\\nvar i, j = 1, 2 //int not needed, var will take the type of the initialiser\\n\\nvar c, python, java = true, false, \\\"no!\\\"\\n\")), mdx(\"h2\", null, \"Short variable declarations (only within functions)\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func main() {\\n    var i, j int = 1, 2\\n    k := 3                      //within fucntions we can omit the var keyword and use :=\\n    c, python, java := true, false, \\\"no!\\\"\\n\\n    fmt.Println(i, j, k, c, python, java)\\n}\\n\")), mdx(\"h2\", null, \"Functions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Functions are first class - \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"allows functions to be assigned to variables, passed as arguments to other functions and returned from other functions.\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func add(x, y int) int {\\n    return x + y\\n} //adds x and y, returns integer\\n\")), mdx(\"h3\", null, \"Function with multiple results\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func swap(x, y string) (string, string) {\\n    return y, x\\n} // parameter x and y get swapped, two strings get returned\\n\\n\")), mdx(\"h3\", null, \"Named return values\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func split(sum int) (x, y int) {\\n    x = sum * 4 / 9\\n    y = sum - x\\n    return\\n} //a return statement without arguments, returns the named return values, here (x, y int)\\n\")), mdx(\"h3\", null, \"Variables as Functions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Declare a variable as func\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"var funcVar func(int) int\\nfunc incFn(x int) int {\\n    return x + 1\\n}\\nfunc main() {\\n    funcVar = incFn // function on RHS without ()\\n    fmt.Print(funcVar(1))\\n}\\n\")))), mdx(\"h3\", null, \"Functions as Arguments\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Functions can be passes to another functions as arguments\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func applyIt(afunct func (int) int,\\n             val int) int {\\n    return afunct(val)\\n}\\nfunc incFn(x int) int {\\n    return x + 1\\n}\\nfunc main() {\\n    fmt.Print(applyIt(incFn, 2))\\n}\\n\")), mdx(\"h3\", null, \"Anonymous Functions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Don't need to name a function\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func applyIt(afunct func (int) int,\\n             val int) int {\\n    return afunct(val)\\n}\\n\\nfunc main() {\\n    v := applyIt(func (x int) int{return x + 1}, 2)\\n    fmt.Print(v)\\n}\\n\")))), mdx(\"h3\", null, \"Returning Functions and Closures\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Go supports anonymous functions, which can form closures\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"package main\\n\\nimport \\\"fmt\\\"\\n\\nfunc intSeq() func() int {\\n    i := 0\\n    return func() int { // returns anonymous func\\n        i++             // it closes over variable i\\n        return i        // to form closure\\n    }\\n}\\n\\nfunc main() {\\n    nextInt := intSeq() // function value captures its own i value,\\n                        //which will be updated each time we call nextInt\\n\\n    fmt.Println(nextInt())\\n    fmt.Println(nextInt())\\n    fmt.Println(nextInt())\\n\\n    newInts := intSeq()\\n    fmt.Println(newInts())\\n}\\n\")))), mdx(\"h3\", null, \"Variadic and Deferred Functions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Variadic means function can take any number of arguments\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Variable Argument Number\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Functions can take a variable no. of arguments\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Uses ellipses \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"... \"), \"to specify\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Treated as a slice inside function\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func getMax(vals, ...int) int {\\n    maxV := -1\\n    for _, v := range vals {\\n        if v > maxV {\\n            maxV = V\\n        }\\n    }\\n    return maxV\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Variadic Slice Argument\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"can pass slice to a variadic function\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Need the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"...\"), \" suffix\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func main() {\\n    fmt.Println(getMax(1,3,6,4))\\n    vslice := []int{1,3,6,4}\\n    fmt.Println(getMax(vslice...))\\n}\\n\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Deferred Function Calls\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Call can be \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"deferred\"), \" until the surrounding function completes\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Typically used for clean up activities\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"func main() {\\n    i := 1\\n    defer fmt.Println(i+1)\\n    i++\\n    fmt.Println(\\\"Hello\\\")\\n}\\n\")))))))))), mdx(\"h2\", null, \"Arrays\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"fixed length in Go\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Elements are accessed via \", \"[ ]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Index starts at 0\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Elements initialized to zero value by default\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"var x [5]int         //declares array with 5 zeros of int type\\nx[0] = 2\\n________________________\\n//Array literals - An array pre-defined with values\\nvar x [5] int = [5]{1,2,3,4,5}\\nx := [...]{1,2,3,4}                     //... is subsituted with  the length of the literal\\n___________________________\\n//Iterating through arry\\nfor i, v range x {\\n    fmt.Printf(\\\"index %d, value %d\\\", i, v)\\n//range returns two values, the current index and the value at the index\\n\")), mdx(\"h2\", null, \"Slices\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A window on an underlying array, contain a pointer to array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"pointer\"), \" indicates the start of the array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"length\"), \" is the number of elements in the array\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"length of each slice is difference between it's declared indices\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"capacity\"), \" is the max number of elements (from start of slice to end of array)\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"capacities are difference between \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"length of underlying array\"), \" and \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"starting index of slice\"), \".\")))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"array := [...]int{1,2,3,4,5}\\nslice1 := array[1:3]                //2,3\\nslice2 := array[2:5]                //3,4,5\\nfmt.Printf(cap(slice2))             // 3, because starting from index 2, the slice can have 3 elements                                      at most\\n\")), mdx(\"p\", null, \"Length and Capacity\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"len()\"), \" function returns length\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"cap()\"), \" function returns capacity\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"a1 := [3]string{\\\"a\\\",\\\"b\\\",\\\"c\\\"}\\nsli1 := a1[0:1]\\nfmt.Printf(len(sli1),cap(sli1)) // 1 3\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"changing a slice changes the underlying array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"overlapping arrays refer to the same elements, changing it in one slice, also changes it for the other element\")), mdx(\"h2\", null, \"Slice literal\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"creates the underlying array and then the slice that refers to it\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"that means the slice and the array are the same.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"slice points to the start of the array, length equal to capacity\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"//Sliche literal\\nsli := []{1,2,3}            //slices don't need ... in the [ ]\\n\")), mdx(\"h2\", null, \"Variable slices\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"you can also create a slice by using make()\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"make either takes two to three arguments:\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Two: type and length\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sli = make([]int, 10)\"), \" // then length and capacity are equal\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Three arguments : : \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"type, length and capacity\"), \"\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sli = make([]int, 10,15)\"), \" // underlying array len 15 and slice len 10\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Append()\"), \" lets you append elements. If there is space left in the underlying array, it will use that until it is full. Once full and you keep appending, it copies the content and creates a new, bigger underlying array\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \" sli = make([]int, 0, 3) // len of sli is 0\\n sli = append(sli, 100)\\n fmt.Println(len(s), cap(s)) // 1 3\\n\")))), mdx(\"h2\", null, \"Hash table\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"contains key value pairs\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"each value is associated with a unique key\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"hash function is used to compute the slot for the key in the hash table. Input=key, output=slot to put value\")), mdx(\"h3\", null, \"Maps (Go\\u2019s implementation of hash tables)\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"var idMap map[string]int // key type string value type int\\nidMap = make(map[string]int)\\n_____________________________\\n//Map literal\\nidMap := map[string]int {\\n    \\\"joe\\\": 23}\\n\\n_____________________________\\n//Accessing maps\\nfmt.Printf(idMap[\\\"joe\\\"])                //prints 23\\n\\n_____________________________\\n//Adding a key value pair\\nidMap[\\\"Jane\\\"] = 34  //no key \\\"Jane\\\" so the key/val pair gets added\\n\\n______________________________\\n//Editing a key value pair\\nidMap[\\\"Jane\\\"] = 98                  //overrides the old key/val pair\\n\\n____________________________\\n//Deleting a key/val pair\\ndelete(idMap, \\\"joe\\\"\\n\\n_____________________________\\n//Two value assignment to test whether key is in map\\nid, b := idMap[\\\"joe\\\"]                   //id=23, b=true, because joe is a key in the map\\n\\n_____________________________\\n//Number of key/val pairs\\nlen(idMap)\\n\\n_____________________________\\n//Iterating through map\\nfor key, val := range idMap {\\n    fmt.Prinf(key, val)\\n}\\n\")), mdx(\"h2\", null, \"Struct\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Aggregate data type\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Groups together objects of arbitrary types\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"type struct Person {\\n    name string\\n    addr string\\n    phone string\\n}\\nvar p1 Person\\np2 := new(Person) //creates new Person struct with all fields initialized to defaults 0 ir \\\"\\\"\\np1 := Person(name: \\\"joe\\\", addr: \\\"a str\\\", phone: \\\"0123\\\")         //struct literal\\np1.name = \\\"joe\\\"\\n\")), mdx(\"h2\", null, \"Blank identifier\"), mdx(\"p\", null, \"If an assignment requires multiple values on the left side, but one of the values will not be used by the program, a blank identifier on the left-hand-side of the assignment avoids the need to create a dummy variable and makes it clear that the value is to be discarded.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"if _, err := os.Stat(path); os.IsNotExist(err) {\\n    fmt.Printf(\\\"%s does not exist\\\\n\\\", path)\\n}\\n\")), mdx(\"h2\", null, \"JSON\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Format to represent structured Data\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consists of Attribute-Value pairs\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All Unicode\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Types can be combined recursively\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"//Go struct\\ntype struct Person {\\n    name string\\n    addr string\\n    phone string\\n}\\n\\np1 := Person(name: \\\"joh\\\", age:24, phone:\\\"039203\\\")\\n\\n//JSON\\n{\\\"name\\\": \\\"joh\\\", \\\"age\\\":23, \\\"phone\\\":\\\"0320323\\\"}\\n\\n//Marshal creates JSON byte array from Go struct\\nbarr, err := json.Marshal(p1)\\n\\n//Unmarshal converts JSON []byte array into a Go struct\\nvar p2 Person\\nerr := json.Unmarshall(barr, &p2)\\n\\n//the Go struct needs to have the same field names as the JSON object has attributes\\n//if Unmarshal worked, err is nil\\n\")), mdx(\"h2\", null, \"File Access\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Basic operations: - Open - get handle for access - Read - read bytes into []byte - Write - write []bytes into file - Close - release handle - Seek - move read/write head\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Package \\u201Cio/ioutil\\u201D\"))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"dat, err := ioutil.ReadFile(\\\"test.txt\\\")\\n// dat is []byte filled with contents of entire file\\n//no open/close needed when using ReadFile\\n//don't use ReadFile with large files\\n\\ndat = \\\"Hello world\\\"\\nerr := ioutul.WriteFile(\\\"outfile.txt\\\", dat, 0777)\\n// writes []byte to file, creates new file, unix style permission\\n\")), mdx(\"h2\", null, \"OS Package\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"os.Open() -returns file descriptor\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"os.Close() - close a file\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"os.Read() - reads from file into []byte, you can control how big []byte is\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"os.Write() - writes []byte into file\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"f, err := os.Open(\\\"test.txt)\\nbarr := make([]byte, 10)\\nnumber, err := f.read(barr)\\nf.close()\\n//fills barr with first 10 bytes from file, calling it the next time it will read the next 10 bytes --> head moves\\n//number = number of bytes read\\n\")), mdx(\"h2\", null, \"Methods\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"There are two types of methods :\"), mdx(\"ol\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Value receivers : Methods that just do calculations on value, receive value is all they can do\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Pointer receivers : To change a value in struct we need a pointer receiver. You may want to use a pointer receiver type to avoid copying on method calls or to allow the method to mutate the receiving struct\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"No need to de-reference pointer with a \", \"*\"))))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"package main\\n\\nimport \\\"fmt\\\"\\n\\ntype rect struct {\\n    width, height int\\n}\\n\\nfunc (r rect) GetWidth() int {\\n    return r.width\\n}\\n\\nfunc (r *rect) SetWidth(newWidth int) {\\n   r.width = newWidth // modifies struct\\n}\\n\\nfunc main() {\\n    r := rect{width: 10, height: 5}\\n\\n    fmt.Println(\\\"Width: \\\", r.GetWidth())\\n    r.SetWidth(110)\\n    fmt.Println(\\\"Width: \\\", r.GetWidth())\\n}\\n\")))), mdx(\"h2\", null, \"Encapsulation\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"A package is the smallest unit of private encap\\xADsulation in Go.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"All identifiers defined within a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://yourbasic.org/golang/packages-explained/\"\n  }), \"package\"), \" are visible throughout that package.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"When importing a package you can access only its \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"exported\"), \" identifiers.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"An identifier is exported if it begins with a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"capital letter\"), \".\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Example\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In this package, the only exported identifiers are \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopWatch\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Start\"), \".\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"package timer\\n\\nimport \\\"time\\\"\\n\\n// A StopWatch is a simple clock utility.\\n// Its zero value is an idle clock with 0 total time.\\ntype StopWatch struct {\\n    start   time.Time\\n    total   time.Duration\\n    running bool\\n}\\n\\n// Start turns the clock on.\\nfunc (s *StopWatch) Start() {\\n    if !s.running {\\n        s.start = time.Now()\\n        s.running = true\\n    }\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"StopWatch\"), \" and its exported methods can be imported and used in a different package.\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"package main\\n\\nimport \\\"timer\\\"\\n\\nfunc main() {\\n    clock := new(timer.StopWatch)\\n    clock.Start()\\n    if clock.running { // ILLEGAL\\n        // \\u2026\\n    }\\n}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"source: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://yourbasic.org/golang/public-private/\"\n  }), \"yourbasic.org/golang/public-private\")))), mdx(\"h2\", null, \"Interfaces\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Go doesn\\u2019t have inheritance \\u2013 instead composition, embed\\xADding and inter\\xADfaces support code reuse and poly\\xADmorphism\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Interfaces is : Set of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"method signatures\")), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"name parameters, return value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Implementation is NOT defined\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Used to express conceptual similarity between types\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"a\", _extends({\n    parentName: \"strong\"\n  }, {\n    \"href\": \"https://yourbasic.org/golang/interfaces-explained/\"\n  }), \"interfaces\")), \" take care of polymorphism and dynamic dispatch.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"reference : \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://gobyexample.com/interfaces\"\n  }), \"https://gobyexample.com/interfaces\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Type \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"satisfies an interface\"), \" if type defines all methods specified in the interface.\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"same method signatures\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Triangle\"), \" types satisfy the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Shape2D\"), \" interface\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Must have Area() and Perimeter() methods\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Additional methods are OK\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Similar to inheritance and overriding\")), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-go\"\n  }), \"type Shape2D interface {\\n    Area() float64\\n    Perimeter() float64\\n}\\ntype Triangle {...}\\nfunc (t Triangle) Area() float64 {...}\\nfunc (t Triangle) Perimeter() float64 {...}\\n\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Triangle type satisfies the Shape2D interface, no need to state it explicitly.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"These are the notes I made while doing the  Coursera Golang Specialization \nfor quick reference. Objects in Go Go does not use the term…","timeToRead":4,"wordCount":{"words":1126},"frontmatter":{"title":"Golang Notes","tags":["notes","golang"],"date":"2020-06-05T00:00:00.000Z","dateModified":null,"author":"Akshay Ashok","status":null,"isPrivate":null,"url":null,"misc":null,"pinned":null,"featuredImage":null,"featuredImageUrl":null,"embeddedImages":null,"embeddedImageUrls":null},"fields":{"slug":"/posts/golang-notes/","owner":"source","parent":"posts"}}},"pageContext":{"id":"170e7e81-9db3-57c5-b892-711eb472441b","prev":{"frontmatter":{"title":"Gitify - Interact with Git from browser extension.","status":null},"fields":{"slug":"/posts/gitify/"}},"next":{"frontmatter":{"title":"Here's how I made a CLI tool to work with Google Colab notebooks.","status":null},"fields":{"slug":"/posts/colab-cli/"}},"parent":"posts"}},"staticQueryHashes":["1095393795","1402550803","1469902088"]}